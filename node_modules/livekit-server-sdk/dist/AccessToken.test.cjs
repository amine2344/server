"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var import_protocol = require("@livekit/protocol");
var jose = __toESM(require("jose"), 1);
var import_vitest = require("vitest");
var import_AccessToken = require("./AccessToken");
const testApiKey = "abcdefg";
const testSecret = "abababa";
(0, import_vitest.describe)("encoded tokens are valid", () => {
  const t = new import_AccessToken.AccessToken(testApiKey, testSecret, {
    identity: "me",
    name: "myname"
  });
  t.addGrant({ room: "myroom" });
  const EncodedTestSecret = new TextEncoder().encode(testSecret);
  (0, import_vitest.it)("can be decoded", async () => {
    const { payload } = await jose.jwtVerify(await t.toJwt(), EncodedTestSecret, {
      issuer: testApiKey
    });
    (0, import_vitest.expect)(payload).not.toBe(void 0);
  });
  (0, import_vitest.it)("has name set", async () => {
    const { payload } = await jose.jwtVerify(await t.toJwt(), EncodedTestSecret, {
      issuer: testApiKey
    });
    (0, import_vitest.expect)(payload.name).toBe("myname");
  });
  (0, import_vitest.it)("has video grants set", async () => {
    var _a;
    const { payload } = await jose.jwtVerify(await t.toJwt(), EncodedTestSecret, {
      issuer: testApiKey
    });
    (0, import_vitest.expect)(payload.video).toBeTruthy();
    (0, import_vitest.expect)((_a = payload.video) == null ? void 0 : _a.room).toEqual("myroom");
  });
});
(0, import_vitest.describe)("identity is required for only join grants", () => {
  (0, import_vitest.it)("allows empty identity for create", async () => {
    const t = new import_AccessToken.AccessToken(testApiKey, testSecret);
    t.addGrant({ roomCreate: true });
    (0, import_vitest.expect)(await t.toJwt()).toBeTruthy();
  });
  (0, import_vitest.it)("throws error when identity is not provided for join", async () => {
    const t = new import_AccessToken.AccessToken(testApiKey, testSecret);
    t.addGrant({ roomJoin: true });
    await (0, import_vitest.expect)(async () => {
      await t.toJwt();
    }).rejects.toThrow();
  });
});
(0, import_vitest.describe)("verify token is valid", () => {
  (0, import_vitest.it)("can decode encoded token", async () => {
    var _a;
    const t = new import_AccessToken.AccessToken(testApiKey, testSecret);
    t.sha256 = "abcdefg";
    t.kind = "agent";
    t.addGrant({ roomCreate: true });
    t.attributes = { foo: "bar", live: "kit" };
    const v = new import_AccessToken.TokenVerifier(testApiKey, testSecret);
    const decoded = await v.verify(await t.toJwt());
    (0, import_vitest.expect)(decoded).not.toBe(void 0);
    (0, import_vitest.expect)(decoded.sha256).toEqual("abcdefg");
    (0, import_vitest.expect)((_a = decoded.video) == null ? void 0 : _a.roomCreate).toBeTruthy();
    (0, import_vitest.expect)(decoded.kind).toEqual("agent");
    (0, import_vitest.expect)(decoded.attributes).toEqual(t.attributes);
  });
});
(0, import_vitest.describe)("adding grants should not overwrite existing grants", () => {
  const EncodedTestSecret = new TextEncoder().encode(testSecret);
  (0, import_vitest.it)("should not overwrite existing grants", async () => {
    var _a, _b;
    const t = new import_AccessToken.AccessToken(testApiKey, testSecret, {
      identity: "me",
      name: "myname"
    });
    t.addGrant({ roomCreate: true });
    t.addGrant({ roomJoin: true });
    const { payload } = await jose.jwtVerify(
      await t.toJwt(),
      EncodedTestSecret,
      { issuer: testApiKey }
    );
    (0, import_vitest.expect)((_a = payload.video) == null ? void 0 : _a.roomCreate).toBeTruthy();
    (0, import_vitest.expect)((_b = payload.video) == null ? void 0 : _b.roomJoin).toBeTruthy();
  });
});
(0, import_vitest.describe)("room configuration with agents and egress", () => {
  (0, import_vitest.it)("should set agents and egress in room configuration", async () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const t = new import_AccessToken.AccessToken(testApiKey, testSecret, {
      identity: "test-identity"
    });
    const roomConfig = new import_protocol.RoomConfiguration({
      name: "test-room",
      maxParticipants: 10
    });
    const agents = [
      new import_protocol.RoomAgentDispatch({
        agentName: "agent1",
        metadata: "metadata-1"
      }),
      new import_protocol.RoomAgentDispatch({
        agentName: "agent2",
        metadata: "metadata-2"
      })
    ];
    const egress = new import_protocol.RoomEgress({
      room: new import_protocol.RoomCompositeEgressRequest({ roomName: "test-room" })
    });
    roomConfig.agents = agents;
    roomConfig.egress = egress;
    t.roomConfig = roomConfig;
    const v = new import_AccessToken.TokenVerifier(testApiKey, testSecret);
    const decoded = await v.verify(await t.toJwt());
    (0, import_vitest.expect)(decoded.roomConfig).toBeDefined();
    (0, import_vitest.expect)((_a = decoded.roomConfig) == null ? void 0 : _a.name).toEqual("test-room");
    (0, import_vitest.expect)((_b = decoded.roomConfig) == null ? void 0 : _b.maxParticipants).toEqual(10);
    (0, import_vitest.expect)((_c = decoded.roomConfig) == null ? void 0 : _c.agents).toHaveLength(2);
    (0, import_vitest.expect)((_e = (_d = decoded.roomConfig) == null ? void 0 : _d.agents) == null ? void 0 : _e[0].agentName).toEqual("agent1");
    (0, import_vitest.expect)((_g = (_f = decoded.roomConfig) == null ? void 0 : _f.agents) == null ? void 0 : _g[0].metadata).toEqual("metadata-1");
    (0, import_vitest.expect)((_i = (_h = decoded.roomConfig) == null ? void 0 : _h.agents) == null ? void 0 : _i[1].agentName).toEqual("agent2");
    (0, import_vitest.expect)((_k = (_j = decoded.roomConfig) == null ? void 0 : _j.agents) == null ? void 0 : _k[1].metadata).toEqual("metadata-2");
    (0, import_vitest.expect)((_n = (_m = (_l = decoded.roomConfig) == null ? void 0 : _l.egress) == null ? void 0 : _m.room) == null ? void 0 : _n.roomName).toEqual("test-room");
  });
});
//# sourceMappingURL=AccessToken.test.cjs.map